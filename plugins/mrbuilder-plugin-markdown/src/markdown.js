/**
 * class Renderer
 *
 * Generates HTML from parsed token stream. Each instance has independent
 * copy of rules. Those can be rewritten with ease. Also, you can add new
 * rules if you create plugin and adds new token types.
 **/
'use strict';
const { camelCased } = require('mrbuilder-utils');

const escapeHtml = require('markdown-it/lib/common/utils').escapeHtml;
const _Renderer  = require('markdown-it/lib/renderer');

class Renderer extends _Renderer {
    constructor(...args) {
        super(...args);

        this.prelude       = {};
        this.imports       = {
            'React, {Component as $MDComponent}': 'react'
        };
        this.renderImport  = this._renderImport.bind(this);
        this.renderPrelude = this._renderPrelude.bind(this);
    }


    /**
     * Renderer.renderAttrs(token) -> String
     *
     * Render token attributes to string.
     **/
    renderAttrs(token) {
        let i, l, result;

        if (!token.attrs) {
            return '';
        }

        result      = '';
        const attrs = [];
        for (i = 0, l = token.attrs.length; i < l; i++) {
            let [name, value] = token.attrs[i];
            switch (name) {
                case 'class':
                    name  = 'className';
                    value = `"${escapeHtml(value)}"`;
                    break;
                case 'for':
                    name  = 'htmlFor';
                    value = `"${escapeHtml(value)}"`;
                    break;
                case 'style':
                    value = JSON.stringify(
                        value.split(/;/g).reduce(function (ret, key) {

                            const parts = key.split(':', 2);

                            ret[camelCased(parts[0])] = parts[1];

                            return ret;
                        }, {})).replace(/^"(.*)"$/, '$1');
                    value = `{${value}}`;
                    break;
                default:
                    value = `"${escapeHtml(value)}"`;
                    break;
            }
            attrs.push([name, value]);
        }

        for (i = 0, l = attrs.length; i < l; i++) {
            const [name, value] = attrs[i];
            result += ' ' + escapeHtml(name) + '=' + value;
        }

        return result;
    }


    render(tokens, options, env) {
        let i, len, type,
            result = ``,
            rules  = this.rules;

        for (i = 0, len = tokens.length; i < len; i++) {
            type = tokens[i].type;

            if (type === 'inline') {
                result += this.renderInline(tokens[i].children, options, env);
            } else if (typeof rules[type] !== 'undefined') {
                result += rules[tokens[i].type](tokens, i, options, env, this);
            } else {
                result += this.renderToken(tokens, i, options, env);
            }
        }

        return `
${Object.keys(this.imports).map(this.renderImport, this.imports).join(';\n')}
${Object.keys(this.prelude).map(this.renderPrelude, this.prelude).join('')}
//autogenerated class
export default class Markdown extends $MDComponent {

        render(){
          return (<div>${result}</div>);
        }
}`;
    }


    _renderPrelude(key) {
        const value = this.prelude[key];
        if (!value) {
            return '';
        }
        return key;
    }

    _renderImport(key) {
        return `import ${key} from '${ this.imports[key]}'`;
    }
}

module.exports = Renderer;
